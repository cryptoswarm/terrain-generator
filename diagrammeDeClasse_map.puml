@startuml

class WorldGenerator {
    - world : World
    - mode : Mode
    - localization : Localization
    - fileName : String
    - generateWorld(world: World )
    + createWorld()
    + getWorldTileColor(coordinate: Coordinate ) : String
    + getPointColor( coordinate: Coordinate) : String
}

class Line {
    - lineCoordinates: HashSet<Coordinate>
    + isCoordinateValid(c: Coordinate ): boolean
    + getCorners(): HashSet<Coordinate>

}

class Coordinate {
    - x : float
    - y : float
    - z : float
    compareTo(o: Coordinate ): int
    distance(that: Coordinate ): float
}


Interface Shape{
    isInShape(c: Coordinate): boolean
}

class Ellipse{
    - ellipseCenter: Coordinate
    - angle: int
    + isInShape(c: Coordinate): boolean
}

class Circle {
    - center: Coordinate
    - calculateRadiuses(random: RandomContexte )
    + isInShape(c: Coordinate): boolean
}

class Circle implements Shape
class Ellipse implements Shape



Interface Comparable{
    compareTo(o: Coordinate ): int
}

class Coordinate implements Comparable

class Isle {
    - islandTiles: HashSet<Tile>
    + getVegetationTiles(): List<Tile>
    + findRandomVegetationTile(random: RandomContexte ): Tile
    + findRandomTile(random: RandomContexte ):Tile
    + getNeighbor(tile: Tile ): HashSet<Tile>
    + getNeighbor(c: Coordinate ) : HashSet<Tile>
}

interface RandomStrategy{
   + getRandom( range: int) : int
}

class JustRandom {
   + getRandom(range: int ): int
}

class RandomContexte{
    - strategy: RandomStrategy
    + getRandomInt(range: int ): int
}

class Seed {
    - randomness: Random
    + getRandom(range: int ): int
}

class Seed implements RandomStrategy
class JustRandom implements RandomStrategy



class MeshReader{
    + readFile()
    - readMetadata(m: Structs.Mesh , key: String ):String
}

interface Reader{
    readFile()
}

interface Writer{
    generateEndMesh()
}

class MeshWriter{
    - c: WorldGenerator
    - mesh: Structs.Mesh
    - outFileName: String
    - syncMeshBuilderWithMap(): Structs.Mesh
    - setPointColor(builder: Structs.Mesh.Builder )
    - setPolygonColor( builder: Structs.Mesh.Builder)
    - setSegmentColor(builder: Structs.Mesh.Builder )
    + generateEndMesh()

}

class MeshWriter implements Writer
class MeshReader implements Reader

class UserArgs{
    - inputFile : String
    - outputFile: String
    - configure(args: String[] ): CommandLine
    - setPois(pois: String[] )
}


class Border{
    - lines: HashSet<Line>
    - corners: HashSet<Coordinate>
    + getLineColor(line: Line ): TileColor
    + getCorners(): HashSet<Coordinate>
}


class world {
    + addTile(x: float, y: float): void
    + addNeighbor(float x, float y, float nx, float ny): void
    - findRandomTile(): Tile
}


class RandomContexte

Interface WorldProcessor {
    apply(world: world)
    setAquiferCenter(tile: Tile )
    setSoil(soil: soilType )
}

''' Generator '''
Interface Generator {
    generate(w: world): void
}

Class BiomeGenerator{
    - localization: Localization
    - generate(w: World)
}

Class RiverGenerator {
    - nbsRiverSrc: int
    - generate(w: World)
}

Class LakeGenerator {
    - nbsWaterSrc: int
    - generate(w: World)
}

Class IslandGenerator {
    - islandType: String
    - - generate(w: World)
}

BiomeGenerator .up.|> Generator
IslandGenerator .up.|> Generator
RiverGenerator .up.|> Generator
LakeGenerator .up.|> Generator



''' Island '''
Abstract Island {
    + validate(world w): void
}

class Atoll {
    - islandShape: Shape
    - lagoonShape: Shape
    - random: RandomContexte
    - smallRadius: double
    - bigRadius: double
    - center: Coordinate
    + HashMap<Coordinate, Tile> getTiles()
    - isInLagoon(tile: Tile): boolean
    - contains(tile: Tile): boolean
    - getAltitudeProfile(maxAltitude: int, tile: Tile) double
}

Class Tortuga{
    - elypse: Elypse
    - random: RandomContexte
    - spacePercentage: int
    - position: Coordinate
    - contains(tile: Tile): boolean
    - getAltitudeProfile(maxAltitude: int, tile: Tile) double
}

Atoll -up-|> Island
Tortuga -up-|> Island



''' Aquifer '''
Abstract Aquifer {
        + applyHumidityEffect(world: world, waterSource: HashMap<Coordinate, Tile>): void
        - getDistanceFromWaterSource(tile: Tile, waterSource: HashMap<Coordinate, Tile>): float
}

class Lake{
    - aquiferCenter: Tile
    +  apply(isle: Isle )
}

class Nape{
    - aquiferCenter: Tile
    +  apply(isle: Isle )
}

class River{
    findRiverPath(isle: Isle, c: Coordinate, river: HashSet<Line> )
}

class Lake extends Aquifer
class Nape extends Aquifer
class River extends Aquifer

''' Biome '''

Abstract Biome {
    validLocalization(l: Localization , minT: int , maxT: int , minP: int , maxP: int ): Boolean
}


class Ocean{
    - type: String
}

class Plage{
    - type: String
}

class Vegetation{

    - type: String
    + apply(world: World )
}

class Beach{
    - color : TileColor
    + apply(world: World )
}

class Desert{
    - color : TileColor
    + apply(world: World )
}

class IceBeach{
    - color : TileColor
    + apply(world: World )
}

class Lagoon{
    - color : TileColor
    + apply(world: World )
}

class Prairie{
    - color : TileColor
    + apply(world: World )
}

class Beach extends Biome
class Desert extends Biome
class IceBeach extends Biome
class Lagoon extends Biome
class Prairie extends Biome




interface WorldItem{
    getColor() : TileColor
    getType(): String
}

class Lake implements WorldItem
class Nape implements WorldItem
Abstract Biome implements WorldItem

Vegetation -up-|> Biome

Ocean -up-|> Biome
Plage -up-|> Biome

''' Mode '''

Abstract Mode {
    + abstract getColor(): String
    + applyFactor(c: int, factor: int): int
}

class Altitude
class Humidity
class Normal

Altitude -up-|> Mode
Humidity -up-|> Mode
Normal -up-|> Mode

''' world component '''

Class Tile{
    - border: Border
    - Coordinate center
    - TileColor backgroundColor
    - neighbors: HashMap<Coordinate, Tile>
    - int humidityLevel
    + addNeighbor(Tile tile)
}



Tile "1" *--> "1" Border
Tile "1" *--> "1" Coordinate


Border "1" *--> "*" Line
Border "1" *--> "*" Coordinate

Line "1" *--> "2" Coordinate
''' Enum '''

Enum TileColor{
    OCEANBLUE (0,64,128,255)
    WATERBLUE (0,255,255,255)
    SAND (223,159,0,255)
    LIGHTGREEN (0,255,63,255)
    DARKGREEN (0,127,63,255)
    DARKBLUE(0,0,255,255),
    BROWN(165,42,42, 255);
}

Enum soilType {
    DRY ("dry", 100),
    REGULAR ("regular",200),
    WET ("wet", 400);
}



world "1" *--> "*" Tile
world "1" -- "1" soilType
world "1" ..> "1" RandomContexte




Biome .up.|> WorldProcessor
Aquifer .up.|> WorldProcessor
Island ..up.|> WorldProcessor





Lake "1" -- "1" TileColor
Nape "1" -- "1" TileColor
River "1" -- "2" TileColor

Plage "1" -- "1" TileColor
Ocean "1" -- "1" TileColor
Vegetation "1" -- "1" TileColor
Lagoon "1" -- "1" TileColor





@enduml